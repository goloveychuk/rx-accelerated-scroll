{"version":3,"sources":["App.tsx","scroll.ts","reportWebVitals.ts","index.tsx"],"names":["Comp","comp","onNewPos","useState","isCaptured","setCaptured","style","left","x","top","y","height","width","onMouseDown","onMouseUp","onMouseMove","ev","rect","target","getBoundingClientRect","absLayout","movementX","movementY","className","initialModel","page","components","id","modelReducer","model","action","type","map","data","pos","ScrollArea","React","forwardRef","ref","ScrollHandler","memo","App","useReducer","useMemo","initialDelay","maxSpeed","draggable$","BehaviorSubject","scrollArea$","overlap$","combineLatest","pipe","draggable","scrollLayout","overlap","Math","ceil","distinctUntilChanged","scrollSpeed$","switchMap","overlapping","of","totalAccSteps","accelerationTime","accelerationFactor$","concat","interval","take","ind","delay$","delay","accelerationFactor","console","log","subscribe","val","setDraggableAbsLayout","layout","next","setScrollAreaAbsLayout","makeScrollStream","scrollAreaRef","useRef","pageRef","useEffect","clean","scrollSpeed","element","to","speed","start","document","scrollingElement","scrollTop","startTime","Date","getTime","lastAnimatedScroll","diff","animateScroll","now","newScrolltop","requestAnimationFrame","cancelAnimationFrame","scrollTo","current","abs","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.21ec1908.chunk.js","sourcesContent":["import React, {\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { makeScrollStream } from './scroll';\n\ninterface Layout extends Position {\n  width: number;\n  height: number;\n}\n\ninterface Position {\n  x: number;\n  y: number;\n}\ninterface Model {\n  page: { height: number; width: number };\n  components: Comp[];\n}\ninterface Comp extends Position {\n  id: number;\n\n  height: number;\n  width: number;\n}\n\nfunction Comp({\n  comp,\n  onNewPos,\n}: {\n  comp: Comp;\n  onNewPos: (pos: Position, abs: Layout) => void;\n}) {\n  const [isCaptured, setCaptured] = useState(false);\n  const onMouseDown = () => {\n    setCaptured(true);\n  };\n  const onMouseUp = () => {\n    setCaptured(false);\n  };\n\n  const onMouseMove: React.MouseEventHandler<HTMLDivElement> = (ev) => {\n    if (isCaptured) {\n      const rect = (ev.target as HTMLDivElement).getBoundingClientRect();\n      const absLayout: Layout = {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height,\n      };\n      onNewPos(\n        { x: comp.x + ev.movementX, y: comp.y + ev.movementY },\n        absLayout,\n      );\n    }\n  };\n  return (\n    <div\n      style={{\n        left: comp.x,\n        top: comp.y,\n        height: comp.height,\n        width: comp.width,\n      }}\n      onMouseDown={onMouseDown}\n      onMouseUp={onMouseUp}\n      onMouseMove={onMouseMove}\n      className=\"comp\"\n    ></div>\n  );\n}\n\ntype Action = { type: 'setNewPos'; data: { id: number; pos: Position } };\n\nconst initialModel: Model = {\n  page: {\n    height: 14000,\n    width: 900,\n  },\n  components: [{ id: 1, x: 600, y: 300, width: 150, height: 80 }],\n};\n\nconst modelReducer = (model: Model, action: Action): Model => {\n  if (action.type === 'setNewPos') {\n    return {\n      ...model,\n      components: model.components.map((comp) => {\n        if (comp.id === action.data.id) {\n          return { ...comp, ...action.data.pos };\n        }\n        return comp;\n      }),\n    };\n  }\n  return model;\n};\n\nconst scrollAreaHeight = 100;\nconst ScrollArea = React.forwardRef(({}, ref) => {\n  return (\n    <div\n      ref={ref as any}\n      style={{ height: scrollAreaHeight }}\n      className=\"scrollarea\"\n    ></div>\n  );\n});\n\nconst ScrollHandler = React.memo(() => {\n  // const {setNewPosition, scrollSpeed$} = React.useMemo(() => makeScrollStream(), []);\n\n  return null;\n});\n\nconst scrollTo = function (element: HTMLElement, to: number, speed: number) {\n  element = document.scrollingElement as any;\n\n  let start = element.scrollTop;\n  let startTime = new Date().getTime()\n  let lastAnimatedScroll: null | number = null;\n  let diff = 0;\n\n  const animateScroll = function () {\n    lastAnimatedScroll = null;\n    const now = new Date().getTime()\n    const offset = speed * (now - startTime) - diff;\n\n    diff += offset;\n    const newScrolltop = diff + start;\n    element.scrollTop = newScrolltop\n    // console.log(toelement.scrollTop, element.scrollHeight)\n    if (to < newScrolltop) {\n      return\n    }\n    // if (currentTime < duration) {\n      // if (element.scrollTop === lastScrollTop)\n    lastAnimatedScroll = requestAnimationFrame(animateScroll);\n    // } else {\n    //   element.scrollTop = to;\n    // }\n  };\n\n  animateScroll();\n\n  return () => {\n    if (lastAnimatedScroll) {\n      cancelAnimationFrame(lastAnimatedScroll);\n    }\n  };\n};\n\nfunction App() {\n  const [model, action] = useReducer(modelReducer, initialModel);\n\n  const {\n    setDraggableAbsLayout,\n    scrollSpeed$,\n    setScrollAreaAbsLayout,\n  } = React.useMemo(\n    () => makeScrollStream({ initialDelay: 700, maxSpeed: 1 }), // px/ms\n    [],\n  );\n\n  const scrollAreaRef = useRef<HTMLDivElement>();\n  const pageRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    let clean: null | (() => void) = null;\n\n\n    scrollSpeed$.subscribe((scrollSpeed) => {\n      if (clean) {\n        clean();\n      }\n      if (scrollSpeed !== 0) {\n        clean = scrollTo(pageRef.current!, model.page.height-1000, scrollSpeed);\n      }\n    });\n    const rect = scrollAreaRef.current!.getBoundingClientRect();\n    setScrollAreaAbsLayout({\n      x: rect.left,\n      y: rect.top,\n      height: rect.height,\n      width: rect.width,\n    });\n  }, []);\n  return (\n    <div className=\"App\">\n      \n      <ScrollArea ref={scrollAreaRef} />\n      <ScrollHandler />\n      <div\n        ref={pageRef}\n        style={{ height: model.page.height, width: model.page.width }}\n        className=\"page\"\n      >\n      {model.components.map((comp) => {\n          const onNewPos = (pos: Position, abs: Layout) => {\n            action({ type: 'setNewPos', data: { id: comp.id, pos } });\n            setDraggableAbsLayout(abs);\n          };\n          return <Comp key={comp.id} comp={comp} onNewPos={onNewPos} />;\n        })}  \n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import {\n  merge,\n  BehaviorSubject,\n  concat,\n  Subject,\n  of,\n  interval,\n  combineLatest,\n} from 'rxjs';\nimport {\n  map,\n  distinctUntilChanged,\n  switchMap,\n  take,\n  flatMap,\n  mergeMap,\n  delay,\n} from 'rxjs/operators';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface Layout extends Position {\n  width: number;\n  height: number;\n}\n\ninterface ScrollOpts {\n  initialDelay: number;\n  maxSpeed: number;\n  // scrollAreaAbsLayout: Layout\n}\n\nexport const makeScrollStream = ({ initialDelay, maxSpeed }: ScrollOpts) => {\n  const draggable$ = new BehaviorSubject<Layout | null>(null);\n\n  const scrollArea$ = new BehaviorSubject<Layout | null>(null);\n\n  const overlap$ = combineLatest([draggable$, scrollArea$])\n    .pipe(\n      map(([draggable, scrollLayout]) => {\n        if (!draggable || !scrollLayout) {\n          return 0;\n        }\n        const draggableBottom = draggable.y + draggable.height;\n        let overlap = draggableBottom - scrollLayout.y;\n        if (overlap <= 0) {\n          return 0;\n        }\n        overlap = overlap / scrollLayout.height;\n        if (overlap >= 1) {\n          overlap = 1;\n        }\n        overlap = Math.ceil(overlap * 10) / 10;\n        return overlap;\n      }),\n    )\n    .pipe(distinctUntilChanged());\n\n  const overlapping$ = overlap$\n    .pipe(map((overlap) => overlap !== 0))\n    .pipe(distinctUntilChanged());\n\n  const scrollSpeed$ = overlapping$.pipe(\n    switchMap((overlapping) => {\n      if (!overlapping) {\n        return of(0);\n      }\n      const accelerationTime = 1500;\n      const accelerationStep = 100;\n      const totalAccSteps = Math.ceil(accelerationTime/accelerationStep);\n      const accelerationFactor$ = concat(\n        of(-1),\n        interval(accelerationStep),\n      ).pipe(\n        take(totalAccSteps),\n        map(ind => {\n            return (ind + 2) / totalAccSteps\n        })\n      )\n      const delay$ = of(0).pipe(delay(initialDelay));\n\n      return concat(\n        delay$,\n        combineLatest([overlap$, accelerationFactor$]).pipe(\n          map(([overlap, accelerationFactor]) => {\n              console.log('accelerationFactor', accelerationFactor)\n            return overlap * maxSpeed * accelerationFactor\n          }),\n        ),\n      );\n    }),\n  );\n\n  // const scrollSpeed$ = overlap$.pipe(map((overlap) => {\n  //   console.log({overlap})\n  //   return maxSpeed * overlap\n  // }))\n\n  scrollSpeed$.subscribe((val) => {\n    console.log('scrollSpeed$', val);\n  });\n\n  return {\n    setDraggableAbsLayout: (layout: Layout) => draggable$.next(layout),\n    setScrollAreaAbsLayout: (layout: Layout) => scrollArea$.next(layout),\n    scrollSpeed$,\n  };\n};\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}