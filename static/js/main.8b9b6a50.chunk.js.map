{"version":3,"sources":["App.tsx","scroll.ts","reportWebVitals.ts","index.tsx"],"names":["Comp","comp","onNewPos","useState","isCaptured","setCaptured","draggableRef","useRef","onMouseMoveRef","current","ev","rect","getBoundingClientRect","absLayout","x","left","y","top","width","height","movementX","movementY","useEffect","window","addEventListener","ref","style","onMouseDown","onMouseUp","className","initialModel","page","components","id","modelReducer","model","action","type","map","data","pos","ScrollArea","React","forwardRef","ScrollHandler","memo","App","useReducer","useMemo","draggable$","BehaviorSubject","bottomScrollArea$","topScrollArea$","bottomOverlap$","combineLatest","pipe","draggable","scrollLayout","overlap","Math","ceil","distinctUntilChanged","topOverlap$","overlap$","topOverlap","bottomOverlap","setDraggableAbsLayout","layout","next","setBottomScrollAreaAbsLayout","setTopScrollAreaAbsLayout","scrollSpeed$","switchMap","overlapping","of","totalAccSteps","accelerationTime","accelerationFactor$","concat","interval","take","ind","delay$","delay","accelerationFactor","isNegative","speedFactor","pow","abs","makeScrollStream","topScrollArea","bottomScrollArea","pageRef","clean","maxScrollY","document","documentElement","scrollHeight","clientHeight","console","log","subscribe","scrollSpeed","to","element","speed","start","scrollingElement","scrollTop","startTime","Date","getTime","lastAnimatedScroll","diff","direction","animateScroll","now","newScrolltop","requestAnimationFrame","cancelAnimationFrame","scrollTo","topRect","bottomRect","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.8b9b6a50.chunk.js","sourcesContent":["import React, {\n  useEffect,\n  useLayoutEffect,\n  useReducer,\n  useRef,\n  useState,\n} from 'react';\nimport logo from './logo.svg';\nimport './App.css';\nimport { makeScrollStream } from './scroll';\n\ninterface Layout extends Position {\n  width: number;\n  height: number;\n}\n\ninterface Position {\n  x: number;\n  y: number;\n}\ninterface Model {\n  page: { height: number; width: number };\n  components: Comp[];\n}\ninterface Comp extends Position {\n  id: number;\n\n  height: number;\n  width: number;\n}\n\nfunction Comp({\n  comp,\n  onNewPos,\n}: {\n  comp: Comp;\n  onNewPos: (pos: Position, abs: Layout) => void;\n}) {\n  const [isCaptured, setCaptured] = useState(false);\n  const onMouseDown = () => {\n    setCaptured(true);\n  };\n  const onMouseUp = () => {\n    setCaptured(false);\n  };\n\n  const draggableRef = useRef<HTMLDivElement>(null);\n  const onMouseMoveRef = useRef<any>(null);\n  onMouseMoveRef.current = (ev: any) => {\n    if (isCaptured) {\n      const rect = draggableRef.current!.getBoundingClientRect();\n      const absLayout: Layout = {\n        x: rect.left,\n        y: rect.top,\n        width: rect.width,\n        height: rect.height,\n      };\n      onNewPos(\n        { x: comp.x + ev.movementX, y: comp.y + ev.movementY },\n        absLayout,\n      );\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener('mousemove', (ev) => {\n      onMouseMoveRef.current(ev);\n    });\n  }, []);\n\n  return (\n    <div\n      ref={draggableRef}\n      style={{\n        left: comp.x,\n        top: comp.y,\n        height: comp.height,\n        width: comp.width,\n      }}\n      onMouseDown={onMouseDown}\n      onMouseUp={onMouseUp}\n      // onMouseMove={onMouseMove}\n      className=\"comp\"\n    ></div>\n  );\n}\n\ntype Action = { type: 'setNewPos'; data: { id: number; pos: Position } };\n\nconst initialModel: Model = {\n  page: {\n    height: 14000,\n    width: 900,\n  },\n  components: [{ id: 1, x: 600, y: 300, width: 150, height: 80 }],\n};\n\nconst modelReducer = (model: Model, action: Action): Model => {\n  if (action.type === 'setNewPos') {\n    return {\n      ...model,\n      components: model.components.map((comp) => {\n        if (comp.id === action.data.id) {\n          return { ...comp, ...action.data.pos };\n        }\n        return comp;\n      }),\n    };\n  }\n  return model;\n};\n\nconst scrollAreaHeight = 100;\nconst ScrollArea = React.forwardRef(\n  ({ className }: { className: string }, ref) => {\n    return (\n      <div\n        ref={ref as any}\n        style={{ height: scrollAreaHeight }}\n        className={'scrollarea ' + className}\n      ></div>\n    );\n  },\n);\n\nconst ScrollHandler = React.memo(() => {\n  // const {setNewPosition, scrollSpeed$} = React.useMemo(() => makeScrollStream(), []);\n\n  return null;\n});\n\nconst scrollTo = function (element: HTMLElement, to: number, speed: number) {\n  element = document.scrollingElement as any;\n\n  let start = element.scrollTop;\n\n  let startTime = new Date().getTime();\n  let lastAnimatedScroll: null | number = null;\n  let diff = 0;\n\n  const direction = to === 0 ? -1 : 1;\n\n  if (to <= start * direction) {\n    return null;\n  }\n\n  const animateScroll = function () {\n    lastAnimatedScroll = null;\n    const now = new Date().getTime();\n    const offset = speed * (now - startTime) - diff;\n\n    diff += offset;\n    const newScrolltop = diff + start;\n    element.scrollTop = newScrolltop;\n    // console.log(toelement.scrollTop, element.scrollHeight)\n\n    if (to <= newScrolltop * direction) {\n      return;\n    }\n    // if (currentTime < duration) {\n    // if (element.scrollTop === lastScrollTop)\n    lastAnimatedScroll = requestAnimationFrame(animateScroll);\n    // } else {\n    //   element.scrollTop = to;\n    // }\n  };\n\n  animateScroll();\n\n  return () => {\n    if (lastAnimatedScroll) {\n      cancelAnimationFrame(lastAnimatedScroll);\n    }\n  };\n};\n\nfunction App() {\n  const [model, action] = useReducer(modelReducer, initialModel);\n\n  const {\n    setDraggableAbsLayout,\n    scrollSpeed$,\n    setBottomScrollAreaAbsLayout,\n    setTopScrollAreaAbsLayout,\n  } = React.useMemo(\n    () => makeScrollStream({}), // px/ms\n    [],\n  );\n\n  const topScrollArea = useRef<HTMLDivElement>();\n  const bottomScrollArea = useRef<HTMLDivElement>();\n  const pageRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    let clean: null | (() => void) = null;\n\n    const maxScrollY =\n      document.documentElement.scrollHeight -\n      document.documentElement.clientHeight -\n      100;\n    console.log({ maxScrollY });\n    scrollSpeed$.subscribe((scrollSpeed) => {\n      if (clean) {\n        clean();\n      }\n\n      if (scrollSpeed !== 0) {\n        const to = scrollSpeed < 0 ? 0 : maxScrollY;\n        clean = scrollTo(pageRef.current!, to, scrollSpeed);\n      }\n    });\n    const topRect = topScrollArea.current!.getBoundingClientRect();\n    setTopScrollAreaAbsLayout({\n      x: topRect.left,\n      y: topRect.top,\n      height: topRect.height,\n      width: topRect.width,\n    });\n    const bottomRect = bottomScrollArea.current!.getBoundingClientRect();\n    setBottomScrollAreaAbsLayout({\n      x: bottomRect.left,\n      y: bottomRect.top,\n      height: bottomRect.height,\n      width: bottomRect.width,\n    });\n  }, []);\n  return (\n    <div className=\"App\">\n      <ScrollArea className=\"top\" ref={topScrollArea} />\n      <ScrollArea className=\"bottom\" ref={bottomScrollArea} />\n      <ScrollHandler />\n      <div\n        ref={pageRef}\n        style={{ height: model.page.height, width: model.page.width }}\n        className=\"page\"\n      >\n        {model.components.map((comp) => {\n          const onNewPos = (pos: Position, abs: Layout) => {\n            action({ type: 'setNewPos', data: { id: comp.id, pos } });\n            setDraggableAbsLayout(abs);\n          };\n          return <Comp key={comp.id} comp={comp} onNewPos={onNewPos} />;\n        })}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import {\n  merge,\n  BehaviorSubject,\n  concat,\n  Subject,\n  of,\n  interval,\n  combineLatest,\n} from 'rxjs';\nimport {\n  map,\n  distinctUntilChanged,\n  switchMap,\n  take,\n  flatMap,\n  mergeMap,\n  delay,\n} from 'rxjs/operators';\n\ninterface Position {\n  x: number;\n  y: number;\n}\n\ninterface Layout extends Position {\n  width: number;\n  height: number;\n}\n\ninterface ScrollOpts {\n  //   initialDelay: number;\n  //   maxSpeed: number;\n  // scrollAreaAbsLayout: Layout\n}\n\nexport const makeScrollStream = ({}: ScrollOpts) => {\n  const accelerationTime = 1500;\n  const accelerationStep = 100;\n  const initialDelay = 300;\n  const maxSpeed = 1; // px/ms\n  const overlapStep = 0.05;\n  const speedFactorPrec = 1 / 0.01;\n\n  const overlapStepMult = 1 / overlapStep;\n\n  const draggable$ = new BehaviorSubject<Layout | null>(null);\n\n  const bottomScrollArea$ = new BehaviorSubject<Layout | null>(null);\n  const topScrollArea$ = new BehaviorSubject<Layout | null>(null);\n\n\n  const bottomOverlap$ = combineLatest([draggable$, bottomScrollArea$])\n    .pipe(\n      map(([draggable, scrollLayout]) => {\n        if (!draggable || !scrollLayout) {\n          return 0;\n        }\n        const draggableBottom = draggable.y + draggable.height;\n        let overlap = draggableBottom - scrollLayout.y;\n        if (overlap <= 0) {\n          return 0;\n        }\n        overlap = overlap / scrollLayout.height;\n        if (overlap >= 1) {\n          overlap = 1;\n        }\n        // if (overlap === 1) {\n        //     debugger;\n        // }\n        overlap = Math.ceil(overlap * overlapStepMult) / overlapStepMult;\n        return overlap;\n      }),\n    )\n    .pipe(distinctUntilChanged());\n\n  \n\n  const topOverlap$ = combineLatest([draggable$, topScrollArea$])\n    .pipe(\n      map(([draggable, scrollLayout]) => {\n        if (!draggable || !scrollLayout) {\n          return 0;\n        }\n        let overlap = scrollLayout.y + scrollLayout.height - draggable.y;\n        if (overlap <= 0) {\n          return 0;\n        }\n        overlap = overlap / scrollLayout.height;\n        if (overlap >= 1) {\n          overlap = 1;\n        }\n        overlap = Math.ceil(overlap * overlapStepMult) / overlapStepMult;\n    \n        return overlap;\n      }),\n    )\n    .pipe(distinctUntilChanged());\n\n\n  const overlap$ = combineLatest([topOverlap$, bottomOverlap$]).pipe(\n    map(([topOverlap, bottomOverlap]) => {\n      if (bottomOverlap !== 0) {\n        return bottomOverlap;\n      }\n      return -1 * topOverlap;\n    }),\n  );\n\n  const overlapping$ = overlap$\n    .pipe(map((overlap) => overlap !== 0))\n    .pipe(distinctUntilChanged());\n\n  const scrollSpeed$ = overlapping$.pipe(\n    switchMap((overlapping) => {\n      if (!overlapping) {\n        return of(0);\n      }\n\n      const totalAccSteps = Math.ceil(accelerationTime / accelerationStep);\n      const accelerationFactor$ = concat(\n        of(-1),\n        interval(accelerationStep),\n      ).pipe(\n        take(totalAccSteps),\n        map((ind) => {\n          return (ind + 2) / totalAccSteps;\n        }),\n      );\n      const delay$ = of(0).pipe(delay(initialDelay));\n\n      return concat(\n        delay$,\n        combineLatest([overlap$, accelerationFactor$]).pipe(\n          map(([overlap, accelerationFactor]) => {\n            // console.log('accelerationFactor', accelerationFactor);\n            let isNegative = overlap < 0 ? -1 : 1;\n            let speedFactor = Math.pow(Math.abs(overlap), 1.5) * accelerationFactor;\n            speedFactor =\n              Math.ceil(speedFactor * speedFactorPrec) / speedFactorPrec;\n            return speedFactor * maxSpeed * isNegative\n          }),\n        ),\n      );\n    }),\n  );\n\n  // const scrollSpeed$ = overlap$.pipe(map((overlap) => {\n  //   console.log({overlap})\n  //   return maxSpeed * overlap\n  // }))\n\n//   scrollSpeed$.subscribe((val) => {\n//     console.log('scrollSpeed$', val);\n//   });\n  \n\n  return {\n    setDraggableAbsLayout: (layout: Layout) => draggable$.next(layout),\n    setBottomScrollAreaAbsLayout: (layout: Layout) =>\n      bottomScrollArea$.next(layout),\n    setTopScrollAreaAbsLayout: (layout: Layout) => topScrollArea$.next(layout),\n    scrollSpeed$,\n  };\n};\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}